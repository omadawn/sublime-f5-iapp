<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>iappi</string>
		<string>iapp_impl</string>
	</array>
	<key>firstLineMatch</key>
	<string>^package require iapp </string>
	<key>foldingEndMarker</key>
	<string>^\s*\}</string>
	<key>foldingStartMarker</key>
	<string>\{\s*$</string>
	<key>name</key>
	<string>F5 iApp Implementation</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#iapp-names</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#escape</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#comments</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#comments-inline</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#code</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>bare-string</key>
		<dict>
			<key>begin</key>
			<string>(?:^|(?&lt;=\s))"</string>
			<key>comment</key>
			<string>matches a single quote-enclosed word without scoping</string>
			<key>end</key>
			<string>"([^\s\]]*)</string>
			<key>endCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>invalid.illegal.iapp</string>
				</dict>
			</dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#escape</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#variable</string>
				</dict>
			</array>
		</dict>
		<key>code</key>
		<dict>
			<key>comment</key>
			<string>The 'code' definition is a concept borrowed from the Java grammar definition. Essentially it defines what 'code' is with the idea that there is such a thing as a block of code (curly braces) some pieces of code are valid outside of any block others only within one. In the case of java this is a bit simpler since only class can be used outside of any code block body. Others would have to be within some pair of braces somewhere. For scripting languages like TCL it's not as clear. However it's still working but with basically everything included outside of the 'code body'</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#invalids</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#tmsh-commands</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#iapp-utility-commands</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#comments</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#keywords</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#controls</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#further-controls</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#procs</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#escapes</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#iapp-names</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#double-strings</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#sregexes</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#variables</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#tmshvars</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>{</string>
					<key>end</key>
					<string>}</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#code</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>include</key>
					<string>#assertions</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#parens</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#constants-and-special-vars</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#anonymous-classes-and-new</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#storage-modifiers</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#strings</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#all-types</string>
				</dict>
			</array>
		</dict>
		<key>comments</key>
		<dict>
			<key>comment</key>
			<string>Matches TCL style comments</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>comment.line.pound.iappi</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.iappi</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*((#).*$\n?)</string>
					<key>name</key>
					<string>meta.comment.standalone</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.iappi</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Completely empty block comments won't match the in-line syntax below due to the begin/end syntax. (I think they won't)</string>
					<key>match</key>
					<string>\s*(if\s+0\s+\{\})</string>
					<key>name</key>
					<string>comment.block.empty.iappi</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#comments-inline</string>
				</dict>
			</array>
		</dict>
		<key>comments-inline</key>
		<dict>
			<key>comment</key>
			<string>Matches TCL style comments and TCL style 'block comment.' Quotes intentional.</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\s*if\s+0\s+\{</string>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.iappi</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\}</string>
					<key>name</key>
					<string>comment.block.iappi</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>comment.line.semi-pound.iappi</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.iappi</string>
						</dict>
					</dict>
					<key>match</key>
					<string>.+((;\s*#).*$\n?)</string>
				</dict>
			</array>
		</dict>
		<key>controls</key>
		<dict>
			<key>comment</key>
			<string>Control structures like if and foreach</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?&lt;=^|[\[{;])\s*(if|while|for|catch|return|break|continue|switch|exit|foreach)\b</string>
					<key>name</key>
					<string>meta.name.keyword.control.iapp</string>
				</dict>
			</array>
		</dict>
		<key>double-strings</key>
		<dict>
			<key>comment</key>
			<string>Blocks of text surrounded by double quotes</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.iapp</string>
						</dict>
					</dict>
					<key>end</key>
					<string>"</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.iapp</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.iapp</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#escape</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#embeddeds</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#tmshvars</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>embeddeds</key>
		<dict>
			<key>begin</key>
			<string>\[</string>
			<key>beginCaptures</key>
			<dict>
				<key>0</key>
				<dict>
					<key>name</key>
					<string>punctuation.section.embedded.begin.iapp</string>
				</dict>
			</dict>
			<key>end</key>
			<string>\]</string>
			<key>endCaptures</key>
			<dict>
				<key>0</key>
				<dict>
					<key>name</key>
					<string>punctuation.section.embedded.end.iapp</string>
				</dict>
			</dict>
			<key>name</key>
			<string>source.iapp.embedded</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>source.iapp</string>
				</dict>
			</array>
		</dict>
		<key>escapes</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>constant.character.escape.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\\(\d{1,3}|x[a-fA-F0-9]+|u[a-fA-F0-9]{1,4}|.|\n)</string>
				</dict>
			</array>
		</dict>
		<key>further-controls</key>
		<dict>
			<key>comment</key>
			<string>Control structures like else which are only valid if preceeded by a controls</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?&lt;=^|})\s*(then|elseif|else)\b</string>
					<key>name</key>
					<string>meta.name.keyword.control.iapp</string>
				</dict>
			</array>
		</dict>
		<key>iapp-names</key>
		<dict>
			<key>comment</key>
			<string>Matches the special syntax of application name. I'm following the s convention because it can occur multiple times.</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.parameter.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(\$tmsh::app_name)</string>
					<key>name</key>
					<string>meta.name.variable.language.iapp</string>
				</dict>
			</array>
		</dict>
		<key>iapp-utility-commands</key>
		<dict>
			<key>comment</key>
			<string>Commands from the iApp Utility package</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?&lt;=^|[\[{;])\s*(iapp::(is|conf|debug|tmsh_create|substa|template|destination|make_safe_password|tmos_version|get_items|pool_members|apm_config|upgrade_template|downgrade_template))\b</string>
					<key>name</key>
					<string>meta.name.keyword.other.iapp</string>
				</dict>
			</array>
		</dict>
		<key>invalids</key>
		<dict>
			<key>comment</key>
			<string>Matches TCL keywords removed from the iApps implementation of TCL.</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?&lt;=^|[\[{;])\s*(after|auto_execok|auto_load|auto_mkindex|auto_qualify|auto_reset|cd|close|exec|exit|fconfigure|fcopy|fileevent|filename|gets|glob|interp|load|namespace|open|pid|pkg::create|pwd|seek|socket|tcl_findLibrary|tell|update|uplevel|vwait|auto_import|auto_mkindex_old|bgerror|eof|fblocked|file|flush|http|memory|pkg_mkIndex|rename|source|unknown|upvar)\b</string>
					<key>name</key>
					<string>meta.invalid.illegal.iappi</string>
				</dict>
			</array>
		</dict>
		<key>keywords</key>
		<dict>
			<key>comment</key>
			<string>Other TMSH Scripting keywords which have not been defined other places.</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?&lt;=^|[\[{;])\s*(append|array|auto_execok|auto_import|auto_load|auto_mkindex|auto_mkindex_old|auto_qualify|auto_reset|bgerror|binary|cd|clock|close|concat|dde|encoding|eof|error|eval|exec|expr|fblocked|fconfigure|fcopy|file|fileevent|filename|flush|format|gets|glob|global|history|http|incr|info|interp|join|lappend|library|lindex|linsert|list|llength|load|lrange|lreplace|lsearch|lset|lsort|memory|msgcat|namespace|open|package|parray|pid|pkg::create|pkg_mkIndex|puts|pwd|re_syntax|read|registry|rename|resource|scan|seek|set|socket|SafeBase|source|split|string|subst|tcl|tcl_endOfWord|tcl_findLibrary|tcl_startOfNextWord|tcl_startOfPreviousWord|tcl_wordBreakAfter|tcl_wordBreakBefore|tcltest|tclvars|tell|time|trace|unknown|unset|update|uplevel|upvar|variable|vwait)\b</string>
					<key>name</key>
					<string>meta.name.keyword.other.iapp</string>
				</dict>
			</array>
		</dict>
		<key>procs</key>
		<dict>
			<key>comment</key>
			<string>Proc creates a new TCL command (which you could call a function.) The developers guide says this command is invalid but it is used in most modern F5 templates.</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.iapp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.name.function.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>^\s*(proc)\s+([^\s]+)</string>
					<key>name</key>
					<string>meta.name.keyword.other.proc.iapp</string>
				</dict>
			</array>
		</dict>
		<key>regexps</key>
		<dict>
			<key>begin</key>
			<string>(?=\S)(?![\n;\]])</string>
			<key>comment</key>
			<string>matches a single word, named as a regexp, then swallows the rest of the command</string>
			<key>end</key>
			<string>(?=[\n;\]])</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=[^ \t\n;])</string>
					<key>end</key>
					<string>(?=[ \t\n;])</string>
					<key>name</key>
					<string>string.regexp.iapp</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#braces</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#bare-string</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#escape</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>[ \t]</string>
					<key>comment</key>
					<string>swallow the rest of the command</string>
					<key>end</key>
					<string>(?=[\n;\]])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#variable</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#embeddeds</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#escape</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#braces</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>sregexes</key>
		<dict>
			<key>comment</key>
			<string>Some 'special-case' regex thing. I don't quite understand what it does yet. -Aaron</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=^|[\[{;])\s*(regexp|regsub)\b\s*</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.iapp</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>special-case regexp/regsub keyword in order to handle the expression</string>
					<key>end</key>
					<string>[\n;\]]</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>--\s*</string>
							<key>comment</key>
							<string>end of switches</string>
							<key>end</key>
							<string></string>
							<key>match</key>
							<string>\\(?:.|\n)</string>
							<key>name</key>
							<string>constant.character.escape.iapp</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#regexps</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#regexps</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string</key>
		<dict>
			<key>begin</key>
			<string>(?:^|(?&lt;=\s))(?=")</string>
			<key>comment</key>
			<string>matches a single quote-enclosed word with scoping</string>
			<key>end</key>
			<string></string>
			<key>name</key>
			<string>string.quoted.double.iapp</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#bare-string</string>
				</dict>
			</array>
		</dict>
		<key>tmsh-commands</key>
		<dict>
			<key>comment</key>
			<string>Matches tmsh scripting commands such as tmsh::create and tmsh::log</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?&lt;=^|[\[{;])\s*(tmsh::(create|modify|delete|log))\b</string>
					<key>name</key>
					<string>meta.name.keyword.other.iapp</string>
				</dict>
			</array>
		</dict>
		<key>tmshvars</key>
		<dict>
			<key>comment</key>
			<string>tmsh style variables including variables from the presentation section and variables being set. (IE $::myvarname $::mysection__myfield.)</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.parameter.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>((\$|\[set\s+)?::([A-Za-z_][A-Za-z0-9_-]*))</string>
					<key>name</key>
					<string>meta.name.variable.language.iapp</string>
				</dict>
			</array>
		</dict>
		<key>variables</key>
		<dict>
			<key>comment</key>
			<string>Matches regular variables with no global inducing double colon. Plus I modified the match regex because I _think_ it's wrong. I'm sure this is not the right way to do this but it's working for now.</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>variable.parameter.iapp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(\$)((?:[a-zA-Z0-9_][A-Za-z0-9_-]*)(\([^\)]+\))?|\{[^\}]*\})</string>
					<key>name</key>
					<string>meta.variable.other.iapp</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.f5.iapp.impl</string>
	<key>uuid</key>
	<string>e998b591-e630-4583-86bd-b5714d50dd79</string>
</dict>
</plist>
